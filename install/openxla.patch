diff --git a/third_party/tsl/third_party/llvm/annc.patch b/third_party/tsl/third_party/llvm/annc.patch
new file mode 100644
index 0000000000..28dcb4b387
--- /dev/null
+++ b/third_party/tsl/third_party/llvm/annc.patch
@@ -0,0 +1,32 @@
+diff --git a/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp b/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp
+index 61bd23f12601..315063a6141f 100644
+--- a/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp
++++ b/mlir/lib/Conversion/MemRefToLLVM/MemRefToLLVM.cpp
+@@ -906,10 +906,24 @@ struct MemRefCopyOpLowering : public ConvertOpToLLVMPattern<memref::CopyOp> {
+       // We can use memcpy for memrefs if they have an identity layout or are
+       // contiguous with an arbitrary offset. Ignore empty memrefs, which is a
+       // special case handled by memrefCopy.
++      bool cond1 = memrefType.getLayout().isIdentity();
++      bool cond2 = memrefType.hasStaticShape() && memrefType.getNumElements() > 0;
++      bool cond3 = memref::isStaticShapeAndContiguousRowMajor(memrefType);
++      llvm::errs() << "isContiguousMemrefType: " << (cond1 ? "true" : "false") << ", " << (cond2 ? "true" : "false") << ", " << (cond3 ? "true" : "false") << "\n";
++
++      // * intrinsic case:
++      // isContiguousMemrefType: false, true, true
++      // isContiguousMemrefType: false, true, true
++
++      // * function case:
++      // isContiguousMemrefType: true, true, true
++      // isContiguousMemrefType: false, true, false
++
++
+       return memrefType &&
+-             (memrefType.getLayout().isIdentity() ||
+-              (memrefType.hasStaticShape() && memrefType.getNumElements() > 0 &&
+-               memref::isStaticShapeAndContiguousRowMajor(memrefType)));
++             (cond1 ||
++              (cond2 &&
++               cond3));
+     };
+
+     if (isContiguousMemrefType(srcType) && isContiguousMemrefType(targetType))

diff --git a/third_party/tsl/third_party/llvm/workspace.bzl b/third_party/tsl/third_party/llvm/workspace.bzl
index cf8ee42..765d59a 100644
--- a/third_party/tsl/third_party/llvm/workspace.bzl
+++ b/third_party/tsl/third_party/llvm/workspace.bzl
@@ -22,6 +22,7 @@ def repo(name):
             "//third_party/llvm:mathextras.patch",
             "//third_party/llvm:toolchains.patch",
             "//third_party/llvm:zstd.patch",
+            "//third_party/llvm:annc.patch",
         ],
         link_files = {"//third_party/llvm:run_lit.sh": "mlir/run_lit.sh"},
     )

diff --git a/xla/hlo/ir/BUILD b/xla/hlo/ir/BUILD
index 2ffa2da..394018f 100644
--- a/xla/hlo/ir/BUILD
+++ b/xla/hlo/ir/BUILD
@@ -54,6 +54,7 @@ cc_library(
         "hlo_sharding.h",
         "hlo_sharding_metadata.h",
     ],
+    visibility = ["//visibility:public"],
     deps = [
         ":tile_assignment",
         "//xla:array",
diff --git a/xla/service/BUILD b/xla/service/BUILD
index 1a0836c..5b774ce 100644
--- a/xla/service/BUILD
+++ b/xla/service/BUILD
@@ -784,6 +784,7 @@ xla_cc_test(
 cc_library(
     name = "pattern_matcher",
     hdrs = ["pattern_matcher.h"],
+    visibility = ["//visibility:public"],
     deps = [
         ":hlo_parser",
         "//xla:literal_util",
@@ -4830,6 +4831,7 @@ cc_library(
         "hlo_pass_fix.h",
         "hlo_pass_interface.h",
     ],
+    visibility = ["//visibility:public"],
     deps = [
         "//xla:status_macros",
         "//xla:statusor",
@@ -5866,6 +5868,7 @@ cc_library(
     name = "hlo_parser",
     srcs = ["hlo_parser.cc"],
     hdrs = ["hlo_parser.h"],
+    visibility = ["//visibility:public"],
     deps = [
         ":computation_layout",
         ":hlo_lexer",
