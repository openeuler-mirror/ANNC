diff --git a/xla/mlir_hlo/deallocation/transforms/buffer_reuse.cc b/xla/mlir_hlo/deallocation/transforms/buffer_reuse.cc
index 3c9d735e6b..7543ccb788 100644
--- a/xla/mlir_hlo/deallocation/transforms/buffer_reuse.cc
+++ b/xla/mlir_hlo/deallocation/transforms/buffer_reuse.cc
@@ -513,6 +513,12 @@ void promoteBuffers(Block& block) {
 
 struct BufferReusePass : public impl::BufferReusePassBase<BufferReusePass> {
   void runOnOperation() override {
+    func::FuncOp func = dyn_cast<func::FuncOp>(getOperation());
+    assert(func);
+    // Do not run the pass on bodiless functions
+    if (func.isDeclaration())
+      return;
+
     bool result;
     auto& block = getOperation().getBody().front();
     // Copy elimination requires small live-ranges to work well. We only extend
diff --git a/xla/mlir_hlo/deallocation/transforms/deallocate.cc b/xla/mlir_hlo/deallocation/transforms/deallocate.cc
index 90a1ed051f..10079818d1 100644
--- a/xla/mlir_hlo/deallocation/transforms/deallocate.cc
+++ b/xla/mlir_hlo/deallocation/transforms/deallocate.cc
@@ -127,6 +127,9 @@ Value Deallocator::findOwnershipIndicator(Value v) {
 LogicalResult Deallocator::transformModuleOp(ModuleOp op) {
   LogicalResult result = success();
   op.walk([&](func::FuncOp funcOp) {
+    if (funcOp.isDeclaration())
+      return WalkResult::advance();
+
     if (failed(transformFuncOp(funcOp))) {
       result = failure();
       return WalkResult::interrupt();
@@ -212,6 +215,15 @@ FailureOr<TransformResult> Deallocator::transformBlock(Block& block,
 
   TransformResult blockResult;
   for (auto& op : llvm::make_early_inc_range(block.without_terminator())) {
+    if (auto callOp = llvm::dyn_cast<func::CallOp>(op)) {
+      auto callee = llvm::cast<func::FuncOp>(
+        callOp->getParentOfType<ModuleOp>().lookupSymbol(callOp.getCallee()));
+      // If the op is a call op to a bodiless function, skip it, since we will
+      // not be able to transform the function body (since it is not present).
+      if (callee.isDeclaration())
+        continue;
+    }
+
     auto opResult = transformOp(&op, ownedMemrefs);
     if (failed(opResult)) return failure();
     // Remove released memrefs.
diff --git a/xla/mlir_hlo/deallocation/transforms/split_alloc_tensors.cc b/xla/mlir_hlo/deallocation/transforms/split_alloc_tensors.cc
index 0d0bf7a6a7..ed73303b9b 100644
--- a/xla/mlir_hlo/deallocation/transforms/split_alloc_tensors.cc
+++ b/xla/mlir_hlo/deallocation/transforms/split_alloc_tensors.cc
@@ -55,7 +55,12 @@ void splitAllocTensors(Block& block) {
 struct SplitAllocTensorsPass
     : public impl::SplitAllocTensorsPassBase<SplitAllocTensorsPass> {
   void runOnOperation() override {
-    splitAllocTensors(getOperation().getBody().front());
+    func::FuncOp func = dyn_cast<func::FuncOp>(getOperation());
+    assert(func);
+
+    // Do not run the pass on bodiless functions
+    if (!func.isDeclaration())
+      splitAllocTensors(getOperation().getBody().front());
   }
 };
 
