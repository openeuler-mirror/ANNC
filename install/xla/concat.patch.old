diff --git a/home/pablo/boss-project/boss/ANNC/output/2d62952f8989615b3203eac7c92156bc/external/xla/xla/mlir_hlo/BUILD b/xla/mlir_hlo/BUILD
index 2d5ab2dcf6..76e9ebed71 100644
--- a/home/pablo/boss-project/boss/ANNC/output/2d62952f8989615b3203eac7c92156bc/external/xla/xla/mlir_hlo/BUILD
+++ b/xla/mlir_hlo/BUILD
@@ -1255,6 +1255,9 @@ cc_library(
         "transforms/propagate_static_shapes_to_kernel.cc",
         "transforms/test_hlo_transform_dialect_interpreter.cc",
         "transforms/tile_loops_pass.cc",
+        "transforms/tile_linalg_copy_pass.cc",
+        "transforms/dot_to_func_call_pass.cc",
+        "transforms/linalg_copy_to_memref_pass.cc",
         "transforms/unbufferize_pass.cc",
         "transforms/unroll_loops.cc",
     ],
@@ -1513,6 +1516,7 @@ cc_library(
         "gml_st/transforms/compose_extract_insert_slice/compose_extract_insert_slice.cc",
         "gml_st/transforms/copy_removal/copy_removal.cc",
         "gml_st/transforms/cpu_tiling/cpu_tiling_pipeline.cc",
+        "gml_st/transforms/cpu_tiling/reuse_output_tensor.cc",
         "gml_st/transforms/cpu_tiling/fusion_outlining.cc",
         "gml_st/transforms/cpu_tiling/fusion_planning_for_cpu.cc",
         "gml_st/transforms/cpu_tiling/pack_matmul.cc",
@@ -1942,6 +1946,7 @@ cc_library(
     name = "thlo_passes",
     srcs = [
         "thlo/transforms/legalize_sort/legalize_sort.cc",
+        "thlo/transforms/legalize_concat/legalize_concat.cc",
         "thlo/transforms/thlo_passes.h.inc",
     ],
     hdrs = [
diff --git a/home/pablo/boss-project/boss/ANNC/output/2d62952f8989615b3203eac7c92156bc/external/xla/xla/mlir_hlo/thlo/transforms/CMakeLists.txt b/xla/mlir_hlo/thlo/transforms/CMakeLists.txt
index d582d86a72..daae82e9aa 100644
--- a/home/pablo/boss-project/boss/ANNC/output/2d62952f8989615b3203eac7c92156bc/external/xla/xla/mlir_hlo/thlo/transforms/CMakeLists.txt
+++ b/xla/mlir_hlo/thlo/transforms/CMakeLists.txt
@@ -23,6 +23,7 @@ include_directories(BEFORE
 
 add_mlir_library(ThloPasses
   legalize_sort/legalize_sort.cc
+  legalize_sort/legalize_concat.cc
 
   DEPENDS
   MLIRThloPassIncGen
@@ -34,5 +35,6 @@ add_mlir_library(ThloPasses
   MLIRMemRefDialect
   MLIRPass
   MLIRSCFDialect
+  MLIRTensorDialect
   MLIRTransforms
 )
diff --git a/xla/mlir_hlo/thlo/transforms/legalize_concat/legalize_concat.cc b/xla/mlir_hlo/thlo/transforms/legalize_concat/legalize_concat.cc
new file mode 100644
index 0000000000..41474a3571
--- /dev/null
+++ b/xla/mlir_hlo/thlo/transforms/legalize_concat/legalize_concat.cc
@@ -0,0 +1,69 @@
+#include <iterator>
+#include <memory>
+#include <optional>
+#include <utility>
+
+
+#include "mlir/Dialect/Arith/Utils/Utils.h"
+#include "mlir/Dialect/Func/IR/FuncOps.h"
+#include "mlir/Dialect/Tensor/IR/Tensor.h"
+#include "mlir/Pass/Pass.h"
+#include "mlir/Transforms/DialectConversion.h"
+#include "thlo/IR/thlo_ops.h"
+#include "thlo/transforms/passes.h"
+
+namespace mlir {
+namespace thlo {
+
+#define GEN_PASS_DEF_THLOLEGALIZECONCATPASS
+#include "thlo/transforms/thlo_passes.h.inc"
+
+namespace {
+
+struct ConcatenateOpPattern : public OpRewritePattern<ConcatenateOp> {
+  using OpRewritePattern::OpRewritePattern;
+
+  LogicalResult matchAndRewrite(ConcatenateOp op,
+                                PatternRewriter& rewriter) const override {    
+    // Rewrite must happen before bufferization.
+    if (op.hasBufferSemantics())
+      return op->emitError() << "expected tensor semantics";
+    
+    int64_t concatDim = op.getDimension().getSExtValue();
+
+    rewriter.replaceOpWithNewOp<tensor::ConcatOp>(op, /*dim=*/ concatDim,
+                                                    /*inputs=*/ op.getInputs());
+    return success();
+  }
+};  
+
+struct LegalizeConcatPass
+    : public impl::ThloLegalizeConcatPassBase<LegalizeConcatPass> {
+  // Rewrites a thlo.concatenate as a tensor.concat with identical operands and
+  // semantics.
+  void runOnOperation() override {
+    func::FuncOp f = getOperation();
+    MLIRContext* ctx = f.getContext();
+	
+    RewritePatternSet patterns(ctx);
+    patterns.add<ConcatenateOpPattern>(ctx);
+
+    mlir::ConversionTarget target(*ctx);
+    target.markUnknownOpDynamicallyLegal([](Operation*) { return true; });
+    target.addIllegalOp<thlo::ConcatenateOp>();
+
+    if (failed(applyPartialConversion(f, target, std::move(patterns)))) {
+      signalPassFailure();
+    }
+  }
+};
+
+}  // namespace
+
+}  // namespace thlo
+}  // namespace mlir
+
+std::unique_ptr<mlir::OperationPass<mlir::func::FuncOp>>
+mlir::thlo::createLegalizeConcatPass() {
+  return std::make_unique<LegalizeConcatPass>();
+}
diff --git a/home/pablo/boss-project/boss/ANNC/output/2d62952f8989615b3203eac7c92156bc/external/xla/xla/mlir_hlo/thlo/transforms/passes.h b/xla/mlir_hlo/thlo/transforms/passes.h
index 7ac8499f71..1a51f9e9da 100644
--- a/home/pablo/boss-project/boss/ANNC/output/2d62952f8989615b3203eac7c92156bc/external/xla/xla/mlir_hlo/thlo/transforms/passes.h
+++ b/xla/mlir_hlo/thlo/transforms/passes.h
@@ -32,11 +32,15 @@ class FuncOp;
 namespace thlo {
 
 #define GEN_PASS_DECL_THLOLEGALIZESORTPASS
+#define GEN_PASS_DECL_THLOLEGALIZECONCATPASS
 #include "thlo/transforms/thlo_passes.h.inc"
 
 /// Lowers sort to Arith, MemRef, and SCF
 std::unique_ptr<OperationPass<func::FuncOp>> createLegalizeSortPass();
 
+/// Lowers sort to Vector
+std::unique_ptr<OperationPass<func::FuncOp>> createLegalizeConcatPass();
+
 #define GEN_PASS_REGISTRATION
 #include "thlo/transforms/thlo_passes.h.inc"
 
diff --git a/home/pablo/boss-project/boss/ANNC/output/2d62952f8989615b3203eac7c92156bc/external/xla/xla/mlir_hlo/thlo/transforms/thlo_passes.td b/xla/mlir_hlo/thlo/transforms/thlo_passes.td
index be0bdf4381..ade70b3765 100644
--- a/home/pablo/boss-project/boss/ANNC/output/2d62952f8989615b3203eac7c92156bc/external/xla/xla/mlir_hlo/thlo/transforms/thlo_passes.td
+++ b/xla/mlir_hlo/thlo/transforms/thlo_passes.td
@@ -21,4 +21,11 @@ def ThloLegalizeSortPass : Pass<"thlo-legalize-sort", "func::FuncOp"> {
   let constructor = "createLegalizeSortPass()";
   let dependentDialects = ["arith::ArithDialect", "memref::MemRefDialect",
                            "scf::SCFDialect"];
+}
+
+def ThloLegalizeConcatPass : Pass<"thlo-legalize-concat", "func::FuncOp"> {
+  let summary =
+    "Legalize from THLO concat on tensors to MLIR upstream tensor.concat.";
+  let constructor = "createLegalizeConcatPass()";
+  let dependentDialects = ["tensor::TensorDialect"];
 }
\ No newline at end of file
