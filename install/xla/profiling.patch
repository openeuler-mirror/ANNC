diff --git a/xla/mlir/runtime/transforms/jit_compiler.cc b/xla/mlir/runtime/transforms/jit_compiler.cc
index 41abd44c00..7f37b46305 100644
--- a/xla/mlir/runtime/transforms/jit_compiler.cc
+++ b/xla/mlir/runtime/transforms/jit_compiler.cc
@@ -23,6 +23,7 @@ limitations under the License.
 #include <utility>
 #include <vector>
 #include <iostream>
+#include <cstdlib>
 
 #include "absl/status/status.h"
 #include "llvm/ADT/STLExtras.h"
@@ -30,6 +31,7 @@ limitations under the License.
 #include "llvm/Analysis/LoopAnalysisManager.h"
 #include "llvm/IR/Module.h"
 #include "llvm/IR/PassManager.h"
+#include "llvm/IR/LegacyPassManager.h"
 #include "llvm/IR/PassTimingInfo.h"
 #include "llvm/Pass.h"
 #include "llvm/Passes/OptimizationLevel.h"
@@ -416,10 +418,6 @@ int cluster_id = 0;
   engine_options.section_memory_mapper = memory_mapper.get();
   engine_options.symbols_binding = std::move(symbols);
 
-  // Translate MLIR module to the LLVM module.
-  auto llvm_ctx = std::make_unique<llvm::LLVMContext>();
-  auto llvm_module = translateModuleToLLVMIR(compiler->module(), *llvm_ctx);
-
   bool hijack = false;
   int hijackId;
   std::string hijackPath;
@@ -443,8 +441,23 @@ int cluster_id = 0;
     }
   }
 
-  // Hijack the MLIR file if requested by the user
+  // Hijack the MLIR file if requested by the user. We must declare the MLIRContext outside of
+  // the if in case that the hijackedModule is needed somewhere else.
+  mlir::DialectRegistry registry;
+  registry.insert<mlir::LLVM::LLVMDialect>();
+  mlir::registerBuiltinDialectTranslation(registry);
+  mlir::registerLLVMDialectTranslation(registry);
+
+  // NOTE: The MLIRContext must be declared BEFORE OwningOpRef<mlir::ModuleOp>.
+  // Otherwise it will lead to insanely difficult to debug segfaults. More info
+  // here: https://github.com/llvm/llvm-project/issues/95527#issuecomment-2173439013
+  MLIRContext context(registry, MLIRContext::Threading::DISABLED);
+  context.allowUnregisteredDialects(true);
+  OwningOpRef<mlir::ModuleOp> hijackedModule;
+
   if (hijack && cluster_id == hijackId) {
+    // If we are JITing the model we care about (denoted by cluster_id) then
+    // hijack it
     std::cout << "Hijacking from " << hijackPath << " (cluster_id=" << cluster_id << ")\n";
 
     llvm::ErrorOr<std::unique_ptr<llvm::MemoryBuffer>> fileOrErr = llvm::MemoryBuffer::getFileOrSTDIN(hijackPath);
@@ -452,31 +465,123 @@ int cluster_id = 0;
     auto sourceMgr = llvm::SourceMgr();
     auto bufferId = sourceMgr.AddNewSourceBuffer(std::move(*fileOrErr), llvm::SMLoc());
 
-    mlir::DialectRegistry registry;
-    registry.insert<mlir::LLVM::LLVMDialect>();
+    // Parse the input MLIR file.
+    hijackedModule = parseSourceFile<mlir::ModuleOp>(sourceMgr, &context);
 
-    // mlir::registerAllDialects(registry);
-    mlir::registerBuiltinDialectTranslation(registry);
-    mlir::registerLLVMDialectTranslation(registry);
+    if (!hijackedModule) {
+      return compiler->Error("Error can't load file");
+    }
+  }
 
-    MLIRContext context(registry, MLIRContext::Threading::DISABLED);
-    // Parse the input MLIR file.
+  // Check if profiling is enabled.
+  char * profile_fusion_env_var = getenv("XLA_PROFILE_FUSION_CLUSTER");
+  char * profile_fusion_clang_env_var = getenv("XLA_PROFILE_FUSION_CLANG_PATH");
+  int profile_fusion_cluster_id = -1;
 
-    context.allowUnregisteredDialects(true);
+  if (profile_fusion_env_var != NULL && profile_fusion_clang_env_var == NULL ||
+      profile_fusion_env_var == NULL && profile_fusion_clang_env_var != NULL) {
+    return InternalError("if you want to enable profiling you must specify both XLA_PROFILE_FUSION_CLUSTER and XLA_PROFILE_FUSION_CLANG_PATH");
+  }
+  else if (profile_fusion_env_var != NULL && profile_fusion_clang_env_var != NULL) {
+    std::string profile_fusion_cluster_id_str = std::string(profile_fusion_env_var);
+    profile_fusion_cluster_id = std::stoi(profile_fusion_cluster_id_str);
+  }
 
-    OwningOpRef<mlir::ModuleOp> hackedModule = parseSourceFile<mlir::ModuleOp>(sourceMgr, &context);
+  if (cluster_id == profile_fusion_cluster_id) {
+    // If profiling is requested, we need to:
+    // 1. Compile all functions coming from fusion into a separate shared library file.
+    // 2. Remove the body and mark as external such functions in the IR.
+    // After this, the function will be resolved in the shared library file, allowing
+    // the use of an external profiler tool.
+
+    // Clone the original module, which contains both the main functions and the fused ops
+    // exported as functions. The cloned module is the one we will be compiling into
+    // a shared library.
+    mlir::Operation *clonedModule;
+    if (hijackedModule)
+      clonedModule = hijackedModule->clone();
+    else
+      clonedModule = compiler->module()->clone();
+
+    // Remove the main function from our new module, since we just want to compile the
+    // fused ops exported as functions.
+    bool mainErased = false;
+    clonedModule->walk([&](mlir::LLVM::LLVMFuncOp func) {
+      if (func.getName() == "main") {
+        mainErased = true;
+        func.erase();
+      }
+    });
+
+    if (!mainErased) {
+      return InternalError("unable to find main function in module");
+    }
 
-    if (!hackedModule) {
-      return compiler->Error("Error can't load file");
+    // Translate MLIR module to LLVM IR.
+    auto profiling_llvm_ctx = std::make_unique<llvm::LLVMContext>();
+    auto profiling_llvm_module = translateModuleToLLVMIR(clonedModule, *profiling_llvm_ctx);
+
+    // Generate the object file.
+    std::string dest_path = std::tmpnam(nullptr) + std::string(".o");
+    std::error_code EC;
+    llvm::raw_fd_ostream dest(dest_path, EC, llvm::sys::fs::OF_None);
+    if (EC) {
+      return InternalError("failed to create empty file to dump the object file:" + EC.message());
     }
 
-    // If we are JITing the model we care about (denoted by cluster_id) then
-    // hijack it
-    llvm_module = translateModuleToLLVMIR(*hackedModule, *llvm_ctx);
+    llvm::legacy::PassManager PM;
+    if (engine_options.target_machine->addPassesToEmitFile(PM, dest, nullptr, llvm::CodeGenFileType::ObjectFile)) {
+       return InternalError("target failed to generate object file for fusion profiling");
+    }
+    PM.run(*profiling_llvm_module);
+    dest.close();
+
+    // Generate the shared library from the object file.
+    // LLVM does not seem to expose a programatic way to generate a shared library, so here
+    // we use the installed clang binary to generate it.
+    std::string tmp_path = std::tmpnam(nullptr);
+    size_t pos = tmp_path.find_last_of("/\\");
+    engine_options.profiling_lib_file_path = tmp_path.substr(0, pos + 1) + "lljit_fusion_ops_" + tmp_path.substr(pos + 1) + std::string(".so");
+
+    std::string clang_cmd = std::string(profile_fusion_clang_env_var) + std::string("/clang -shared ") + dest_path + std::string(" -o ") + engine_options.profiling_lib_file_path;
+    int result = system(clang_cmd.c_str());
+
+    if (result != 0) {
+      return InternalError("failed to generate shared library, command failed: " + clang_cmd);
+    }
 
-    if (!llvm_module){
-      return compiler->Error("failed to translate module to LLVM IR");
+    // We do not need the temporary .o file anymore, delete it.
+    if (std::remove(dest_path.c_str()) != 0) {
+      return InternalError("failed to delete the temporary object file");
     }
+
+    // Remove the body of the fused ops exported as functions from the original module and mark them as
+    // external, as we want the function call to be redirected to the shared library we have just created.
+    auto remove_fusion_funcs = [&](mlir::LLVM::LLVMFuncOp func) {
+      // The fused functions are marked with the "fusion" attribute.
+      if (func->getAttr("fusion"))  {
+        func.setVisibility(mlir::LLVM::LLVMFuncOp::Visibility::Private);
+        func.eraseBody();
+      }
+    };
+
+    if (hijackedModule)
+      hijackedModule->walk(remove_fusion_funcs);
+    else
+      compiler->module()->walk(remove_fusion_funcs);
+  }
+
+  // Translate MLIR module to the LLVM module.
+  auto llvm_ctx = std::make_unique<llvm::LLVMContext>();
+  std::unique_ptr<llvm::Module> llvm_module;
+
+  if (hijackedModule)
+    llvm_module = translateModuleToLLVMIR(*hijackedModule, *llvm_ctx);
+  else
+    llvm_module = translateModuleToLLVMIR(compiler->module(), *llvm_ctx);
+
+  if (!llvm_module) {
+    return compiler->Error("failed to translate module to LLVM IR");
   }
 
   if (dump_llvm_path_env_var != NULL) {
diff --git a/xla/runtime/execution_engine.cc b/xla/runtime/execution_engine.cc
index 66297c9076..294ba84407 100644
--- a/xla/runtime/execution_engine.cc
+++ b/xla/runtime/execution_engine.cc
@@ -395,6 +395,14 @@ ExecutionEngine::CreateFromModule(std::unique_ptr<llvm::LLVMContext> ctx,
   llvm::orc::JITDylib &main_jd = (*jit)->getMainJITDylib();
   llvm::DataLayout data_layout = (*jit)->getDataLayout();
 
+  if (!options.profiling_lib_file_path.empty()) {
+    // Load the shared library that contains the fused ops functions.
+    std::string errMsg;
+    if (llvm::sys::DynamicLibrary::LoadLibraryPermanently(options.profiling_lib_file_path.c_str(), &errMsg)) {
+      return InternalError("failed to load shared library for profiling: %s", errMsg);
+    }
+  }
+
   char * load_object_path_env_var = getenv("XLA_MLIRJIT_LOAD_OBJECT_PATH");
   char * load_libs_path_env_var = getenv("XLA_MLIRJIT_LOAD_LIB_PATHS");
 
diff --git a/xla/runtime/execution_engine.h b/xla/runtime/execution_engine.h
index f7e3c299a7..0633262422 100644
--- a/xla/runtime/execution_engine.h
+++ b/xla/runtime/execution_engine.h
@@ -104,6 +104,13 @@ class ExecutionEngine {
 
     // Save compiled object file.
     bool save_compiled_obj_file = true;
+
+    // If profiling is enabled, the LLJIT compiler will compile the functions
+    // coming from fused operators in a separate shared library and load it at
+    // runtime. Doing so allows external tools (such as perf) to track which
+    // function was called. The `profiling_obj_file_path` attribute stores
+    // the path of the shared library generated by the JIT.
+    std::string profiling_lib_file_path;
   };
 
   // Creates a new execution engine by compiling the provided LLVM module to
diff --git a/xla/service/cpu/hlo_xla_runtime_pipeline.cc b/xla/service/cpu/hlo_xla_runtime_pipeline.cc
index 85a65dd76c..5e062c0755 100644
--- a/xla/service/cpu/hlo_xla_runtime_pipeline.cc
+++ b/xla/service/cpu/hlo_xla_runtime_pipeline.cc
@@ -137,12 +137,25 @@ void AddSparsificationPassPipeline(mlir::OpPassManager& pm) {
 
 }  // namespace
 
+static Status CheckHloXlaRuntimePipelineOptionsLegality(HloXlaRuntimePipelineOptions options) {
+  if (getenv("XLA_PROFILE_FUSION_CLUSTER") != NULL) {
+    if (!options.enable_tiling_and_fusion || !options.enable_fusion_outlining)
+      return absl::InternalError("profiling was requested with XLA_PROFILE_FUSION_CLUSTER, but tiling_and_fusion and/or fusion_outlining are disabled");
+  }
+  return absl::OkStatus();
+}
+
 // -------------------------------------------------------------------------- //
 // Assemble a HLO XLA Runtime pipeline to lower from HLO to Linalg on buffers.
 // -------------------------------------------------------------------------- //
 
 static Status CreateHloXlaPipeline(
     mlir::OpPassManager& pm, const HloXlaRuntimePipelineOptions& options) {
+  // First, make sure that the passed options are legal.
+  Status legalOptions = CheckHloXlaRuntimePipelineOptionsLegality(options);
+  if (!legalOptions.ok())
+    return legalOptions;
+
   // Resolve all shape constraints (e.g. broadcast constraints that can be
   // proved statically and changed to const witness) early to allow more
   // efficient broadcast operations moving.
